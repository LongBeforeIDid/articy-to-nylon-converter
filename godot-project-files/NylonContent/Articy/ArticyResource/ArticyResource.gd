@abstract
class_name ArticyResource extends ArticyResourceBaseSources
## The base class for resources containing the data from an Arcity node.

var assigned_sequence: NylonSequence

var aatt_array: Array[ArticyAddToTree] = []

var creates_node: bool = true


## Executes [method _process_incoming], [method _process_main], and
## [method _process_outgoing], then returns the modified [member aatt_array].[br][br]
##
## The converter calls this function once per [ArticyResource].[br][br]
##
## You probably don't want to override this one, and should override
## the three functions it calls instead.
func _generate_nylon() -> Array[ArticyAddToTree]:
	ArticyDebug.log_ar_properties(self)
	_process_incoming()
	_process_main()
	_process_outgoing()
	
	return aatt_array


## The first of three overridable functions that generate [ArticyAddToTree]
## instructions and return them to the converter.[br][br]
##
## This function handles everything needed to accomodate incoming connections.
## Unless overriden, this means generating a [NylonSequence] node for each
## pin and assigning that pin's unique id as the node's name.[br][br]
##
## When you override this, you should always run [code]super[/code] before
## your custom code, unless you're extending a Container class and implementing
## custom incoming connection behaviour manually.
func _process_incoming():
	for aatt in _create_pin_aatt_array():
		aatt_array.append(aatt)


## The second of three overridable functions that generate [ArticyAddToTree]
## instructions and return them to the converter.[br][br]
## 
## This function is responsible for creating all non-connection related
## [NylonNode]s. (e.g The [NylonText] node for an [ArticyDialogueFragment],
## the [NylonInstruction] node for an [ArticyInstruction], or any recipe of nodes
## that you've decided to represent with a single custom template in Articy.)[br][br]
## 
## When you override this function, you must always run [code]super[/code] first,
## otherwise the converter's logic will break. The sequences generated by
## [method _process_incoming] are expecting to connect with the sequence
## generated by [method _create_sequence_att] within this base function, and
## they will fail to connect if it doesn't exist.[br][br]
## 
## See [ArticyAddToTree] for more details on how to override this function
## with your own custom behaviour.
func _process_main():
	aatt_array.append(_create_sequence_aatt())


## The third of three overridable functions that generate [ArticyAddToTree]
## instructions and return them to the converter.[br][br]
##
## This function is responsible for handling all of the [ArticyResource]'s
## outgoing connections by creating the appropriate [NylonNode]s. As implemented,
## this broadly means any [NylonNode] with the [code]target_scene[/code]
## property (specifically, it means [NylonGoToSequence], [NylonChoice], and any
## classes that inherit from those two.)[br][br]
##
## By default, the base function will generate an [ArticyAddToTree] instruction
## containing a [NylonGoToSequence] node, which will connect to the sequence 
## named [member active_target_pin.id]. This provides the expected behaviour
## for any non-branching node.
func _process_outgoing():
	aatt_array.append(create_goto_aatt())


func create_aatt() -> ArticyAddToTree:
	var aatt = ArticyAddToTree.new()
	aatt.ar = self
	return aatt


func create_goto_aatt() -> ArticyAddToTree:
	var aatt_goto: ArticyAddToTree = create_aatt()
	aatt_goto.node = NylonGoToSequence.new()
	
	if active_target_pin:
		aatt_goto.target_sequence_id = active_target_pin.id
	
	return aatt_goto


func _create_sequence_aatt() -> ArticyAddToTree:
	var aatt = create_aatt()
	aatt.node = NylonSequence.new()
	aatt.node.name = id
	return aatt


func _create_pin_aatt_array(pins: Array[ArticyPin] = input_pins) -> Array:
	var array = []
	for pin in pins:
		for aatt in pin.create_aatt_array():
			array.append(aatt)
	return array
